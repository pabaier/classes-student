/**
 * CSCI 221, HW 2 (McCauley)
 * Base code provided by instructor and updated by:
 * 
 * <Your name goes here>
 */

import java.util.*;
import java.io.*;
import java.awt.*;

public class MapDataDrawer
{
  // store map data in grid array
  private int[][] grid; 
  
  // Read 2D array into grid. Data in file "filename", grid is rows x cols
   public MapDataDrawer(String filename, int rows, int cols) throws Exception{
      // initialize grid 
      grid = new int[rows][cols];
      //read the data from the file into the grid
      Scanner S = new Scanner(new File(filename));    
      
       for(int row=0; row < grid.length; row++){
          for(int col=0; col<grid[0].length; col++){
             grid[row][col] = S.nextInt(); 
          }
       }
      
  }

  
  /**
   * @return the min value in the entire grid
   */
  public int findMin(){
      int i;
      int j;
      int minValue = Integer.MAX_VALUE;
      for(i = 0; grid.length > i; i++){
          for(j = 0; grid[0].length > j; j++){
              if( grid[i][j] < minValue){
                  minValue = grid[i][j];
              } 
          }
      }
      
      return minValue;  
  }
  
  /**
   * @return the max value in the entire grid
   */
  public int findMax(){
      int i;
      int j;
      int MAX_VALUE = 0;
       for(i = 0; grid.length > i; i++){
          for(j = 0; grid[0].length > j; j++){
              if( grid[i][j] > MAX_VALUE){
                  MAX_VALUE = grid[i][j];
              } 
          }
      }

      return MAX_VALUE; //Integer.MAX_VALUE; 
  }
  
  /**
   * @param col the column of the grid to check
   * @return the index of the row with the lowest value in the given col for the grid
   */
  public  int indexOfMinRow(int col){
      int i = 0;
      int minRow = grid[i][col];
      for(i = 0; i < grid.length; i++){
         if(grid[col][i] < minRow){
             minRow = grid[i][col];
         }
      }
      return 0; 
  }
  
  
  /**
   * DON'T CHANGE THIS CODE
   * Draws the grid using the given Graphics object. 
   * Colors should be grayscale values 0-255, scaled based on min/max values in grid
   * 
   * ALERT:Until your findMin and findMax methods work, your output will
   * be a completely black graph.
   */
  public void drawMap(Graphics g){
      
    int minVal = findMin();
    int maxVal = findMax();
    double range = maxVal - minVal;
    
    for(int row=0; row < grid.length; row++){
      for(int col=0; col<grid[0].length; col++){
         int val = (int)(((grid[row][col]-minVal)/range) * 255);
         //g.setColor(new Color(val,255-val,255-val));
         g.setColor(new Color(val,val,val));
         g.fillRect(col,row,1,1);
        }
    }      
  }
  

   /**
   * Find a path from West-to-East starting at given row.
   * Choose a foward step out of 3 possible forward locations, using greedy method described in assignment.
   * @return the total change in elevation traveled from West-to-East
   */
  
  public int drawLowestElevPath(Graphics g, int row){
    int currY = row; // row in grid of step one
    int i;
    int j;
    int optA;
    int optB;
    int optC;
    // draw initial step - column 0, current row (sent in as parameter)
   
     g.fillRect(0,row,1,1);
    
    // draw next step where x is currently column and currY is row in grid
    
    // the value of x will be generated by a loop that goes through the
    // columns, but for now, need something to put in "paint" statement
    
    int changeInElv = 0;
      for(int x = 0; x < grid[0].length - 1; x++ ){
        //for(int x = 0; x <= 0; x++ ){     
        /*---------------TOP EDGE CASE-------------------*/   
        if(currY == 0){
           optB = Math.abs(grid[currY][x] - grid[currY][x + 1]);
           optC = Math.abs(grid[currY][x] - grid[currY + 1][x + 1]);
           
           if(optB < optC){
               g.fillRect(x,currY,1,1);
               changeInElv += optB; // repeat everytime there is an if;
           }else if(optC < optB){
               currY++;
               g.fillRect(x,currY,1,1);
               changeInElv += optC;
           }else if(optC == optB){
            g.fillRect(x,currY,1,1);
            }
           
        /*-------------------BOTTOM EDGE CASE-------------------*/
        }else if(currY ==  grid.length - 1){
           optA = Math.abs(grid[currY][x] - grid[currY - 1][x + 1]);
           optB = Math.abs(grid[currY][x] - grid[currY][x + 1]);
           
           if(optA < optB){
               currY--;
               g.fillRect(x,currY,1,1);
               changeInElv += optA;
            }else if(optB < optA){
               g.fillRect(x,currY,1,1);
               changeInElv += optB;
            }else if(optA == optB){
                currY--;
                g.fillRect(x,currY,1,1);
            
            }
        /*----------------------MIDDLE CASE---------------------------*/    
        } else{
           //System.out.println(x + " "+ currY);
           optA = Math.abs(grid[currY][x] - grid[currY - 1][x + 1]);
           optB = Math.abs(grid[currY][x] - grid[currY][x + 1]);
           optC = Math.abs(grid[currY][x] - grid[currY + 1][x + 1]);
           
           //CASES 1 & 2----------------------
           if(optA < optB && optA < optC){
               currY--;
               g.fillRect(x,currY,1,1);
               changeInElv += optA;
            }else if(optB < optA && optB < optC){
                g.fillRect(x,currY,1,1);
                changeInElv += optB;
            }else if(optC < optA && optC < optB){
               currY++;
               g.fillRect(x,currY,1,1);
               changeInElv += optC;
            }
            //CASE 3-------------------------
            else if(optA == optB){
                //currY--;
                g.fillRect(x,currY,1,1); 
                changeInElv += optC;
            }else if(optB == optC){
                //currY++;
                g.fillRect(x,currY,1,1);
                changeInElv += optA;
            }
            //CASE 4------------------------
            else if(optA == optC){
                if(optA < optB && optC < optB){
                    double coin = Math.random();
                    //coin flip
                    if(coin < .5){
                       currY++;
                       g.fillRect(x,currY,1,1);
                    }else if(coin > .5){
                       currY--;
                       g.fillRect(x,currY,1,1);
                    }
                    changeInElv += optA;
                }else if(optB < optA && optB < optC){
                    g.fillRect(x,currY,1,1);
                    changeInElv += optB;
                }
            
            }
        }//middle else close 
            
     
    }//for loop close
   
            
    System.out.println(changeInElv + " CIE");
    return changeInElv; // computed change in elevation
}

  /**
   * @return the index of the starting row for the lowest-elevation-change path in the entire grid.
   */
  public int indexOfLowestElevPath(Graphics g){
      int lowestPath = drawLowestElevPath(g, 0);
      int indexOfLowest = 0;
      for(int i = 0; i < grid.length; i++){
          int currentPath = drawLowestElevPath(g, i);
          System.out.println(drawLowestElevPath(g,i)+ " DLEP");
          if(lowestPath > currentPath){
              lowestPath = currentPath;
              indexOfLowest = i;
              System.out.println(lowestPath+ " LOWEST PATH INDEX");
            }
        //System.out.println(lowestPath);
        System.out.println(i+" i counter");
          
        }
      
       
        //System.out.println("YEAAAAAAAABOYYYYIIIIIIIIIII "+lowestPath);
      return indexOfLowest; // row of path with lowest elevation
      
  }
  
  
}