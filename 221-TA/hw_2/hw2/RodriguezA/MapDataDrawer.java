/*
 * CSCI 221, HW 2 (McCauley)
 * Base code provided by instructor and updated by:
 * 
 * <Angelica Rodriguez>
 */

import java.util.*;
import java.io.*;
import java.awt.*;

public class MapDataDrawer
{
  // store map data in grid array
  private int[][] grid; 
  
  // Read 2D array into grid. Data in file "filename", grid is rows x cols
   public MapDataDrawer(String filename, int rows, int cols) throws Exception{
      // initialize grid 
      grid = new int[rows][cols];
      //read the data from the file into the grid
      Scanner S = new Scanner(new File(filename));    
      
       for(int row=0; row < grid.length; row++){
          for(int col=0; col<grid[0].length; col++){
             grid[row][col] = S.nextInt(); 
          }
       }
      
  }

  
  /**
   * @return the min value in the entire grid
   */
  public int findMin(){
	  int minMin=grid[0][0];
	  int row=0;
	  int col= 0;
	  for(row=0;row<grid.length;row++) {
		  for(col=0; col<grid[0].length;col++) {
			  if(grid[row][col]<minMin) {
				  minMin=grid[row][col];
				  
			  }
		  }
	  }
  
      return minMin;  
  }
  
  /**
   * @return the max value in the entire grid
   */
  public int findMax(){
	  int Max=grid[0][0];
	  int row=0;
	  int col=0;
	  
	  for(row=0;row<grid.length;row++){
		  for(col=0;col<grid[0].length;col++) {
			  if(grid[row][col]>Max) {
				  Max=grid[row][col];
			  }
		  }
	  }

      return Max; 
  }
  
  /**
   * @param col the column of the grid to check
   * @return the index of the row with the lowest value in the given col for the grid
   */
  public  int indexOfMinRow(int col){
	  int Min=grid[0][col];
	  int rowMin=0;
	  int i=0;
	  for(i=1; i<grid.length; i++) {
		  if(grid[i][col]<Min) {
			  Min=grid[i][col];
			  rowMin=i;
		  }
	  }
      
      return rowMin;  
  }
  
  
  /**
   * DON'T CHANGE THIS CODE
   * Draws the grid using the given Graphics object. 
   * Colors should be grayscale values 0-255, scaled based on min/max values in grid
   * 
   * ALERT:Until your findMin and findMax methods work, your output will
   * be a completely black graph.
   */
  public void drawMap(Graphics g){
      
    int minVal = findMin();
    int maxVal = findMax();
    double range = maxVal - minVal;
    
    for(int row=0; row < grid.length; row++){
      for(int col=0; col<grid[0].length; col++){
         int val = (int)(((grid[row][col]-minVal)/range) * 255);
         //g.setColor(new Color(val,255-val,255-val));
         g.setColor(new Color(val,val,val));
         g.fillRect(col,row,1,1);
        }
    }      
  }
  

   /**
   * Find a path from West-to-East starting at given row.
   * Choose a foward step out of 3 possible forward locations, using greedy method described in assignment.
   * @return the total change in elevation traveled from West-to-East
   */
  public int drawLowestElevPath(Graphics g, int row){
    int currY = row; // row in grid of step one
    int Max = findMax();
    int x = 0;
    int Total=0;
    int forWard=grid[currY][x+1];
    int upWards=-1;
    int downWards=-1;
    int currYForwards=Math.abs(grid[currY][x]-forWard);
    int currYDownwards=Max+1;
    int currYUpwards=Max+1;
    int Less=currYDownwards;
  
    for(x=0;x<grid[0].length-1;x++) {
    	g.fillRect(0,row,1,1);
    	g.fillRect(x,currY,1,1);
    	
    	if(row !=0) {
    		upWards= grid[row + 1][x + 1];
    	}
    	if(row !=grid.length - 1) {
    		downWards=grid[row + 1][x + 1];
    	}
    	
    	if(upWards>-1) {
    		currYUpwards=Math.abs(grid[row][x]-forWard);
    	}
    	if(downWards>-1) {
    		currYDownwards=Math.abs(grid[currY][x]-downWards);
    	}
    	if(currYForwards>currYUpwards) {
    		if(currYUpwards>currYDownwards) {
    			Less=currYDownwards;
    			currY++;
    		}
    		else {
    			Less=currYUpwards;	
    			currY--;
    		}
    	}
    	else {
    		if(currYForwards>currYDownwards){
    			Less=currYDownwards;
    			currY++;
    		}
    		else {
    			Less=currYForwards;
    	}
    		
    	}
    	Total+=Less;
    	
    
    // draw initial step - column 0, current row (sent in as parameter)
    
    
    // Code to compute next step
    
    // draw next step where x is currently column and currY is row in grid
    // the value of x will be generated by a loop that goes through the
    // columns, but for now, need something to put in "paint" statement
    }
   return Total;
  
  }
  
    
    
    // computed change in elevation
  
  /**
   * @return the index of the starting row for the lowest-elevation-change path in the entire grid.
   */
  public int indexOfLowestElevPath(Graphics g){
	  
	  
	  int i=0;
	  int Less=drawLowestElevPath(g,i);
	  int index=0;
	  for(i=1;i<grid.length;i++){
		 
		  if(grid[0][i]<Less) {
			  Less=grid[i][i];
			  index--;
			  index--;
			  index=i;
			  
	 
		  }
		
	   
  
	  }
		  
	  
     
      return index ; // row of path with lowest elevation
  
  }
  
  
}