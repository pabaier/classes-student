/**
 * CSCI 221, HW 2 (McCauley)
 * Base code provided by instructor and updated by:
 * 
 * Andrea Lingenfelter
 */

import java.util.*;
import java.io.*;
import java.awt.*;

public class MapDataDrawer
{
  // store map data in grid array
  private int[][] grid; 
  
  // Read 2D array into grid. Data in file "filename", grid is rows x cols
   public MapDataDrawer(String filename, int rows, int cols) throws Exception{
      // initialize grid 
      grid = new int[rows][cols];
      //read the data from the file into the grid
      Scanner S = new Scanner(new File(filename));    
      
       for(int row=0; row < grid.length; row++){
          for(int col=0; col<grid[0].length; col++){
             grid[row][col] = S.nextInt(); 
          }
       }
      
  }

  
  /**
   * @return the min value in the entire grid
   */
  public int findMin(){
	  int min = grid[0][0];
	  for (int i = 0; i < grid.length; i++) {
		  for(int j = 0; j < grid[0].length; j++) {
			  if(grid[i][j] < min) {
				  min = grid[i][j];
			  }
		  }
	  }
	  // test: System.out.println("min: " + min);
      return min;  
  }
  
  /**
   * @return the max value in the entire grid
   */
  public int findMax(){
	  int max = grid[0][0];
	  for (int i = 0; i < grid.length; i++) {
		  for (int j = 0; j < grid[0].length; j++) {
			  if (grid[i][j] > max) {
				  max = grid[i][j];
			  }
		  }
	  }
	  // test System.out.println("max: " + max);
      return max; 
  }
  
  /**
   * @param col the column of the grid to check
   * @return the index of the row with the lowest value in the given col for the grid
   */
  public  int indexOfMinRow(int col){
      int index = 0;
      int min = grid[0][0];
      for (int i = 0; i < grid.length; i++) {
    	  if(grid[i][col] < min) {
    		  min = grid[i][col];
    		  index = i;
    	  }
      }
      //test System.out.println("lowestRow: " + index)
      return index;  
  }
  
  
  /**
   * DON'T CHANGE THIS CODE
   * Draws the grid using the given Graphics object. 
   * Colors should be grayscale values 0-255, scaled based on min/max values in grid
   * 
   * ALERT:Until your findMin and findMax methods work, your output will
   * be a completely black graph.
   */
  public void drawMap(Graphics g){
      
    int minVal = findMin();
    int maxVal = findMax();
    double range = maxVal - minVal;
    //code added to test range variable bc map color error (caused by needing correct min
    //had been returning aprox 1300 bc taken length or rows instead of columns
    //System.out.println("Range: " + range);
    
    for(int row=0; row < grid.length; row++){
      for(int col=0; col<grid[0].length; col++){
         int val = (int)(((grid[row][col]-minVal)/range) * 255);
         //g.setColor(new Color(val,255-val,255-val));
         g.setColor(new Color(val,val,val));
         g.fillRect(col,row,1,1);
        }
    }      
  }
  

   /**
   * Find a path from West-to-East starting at given row.
   * Choose a foward step out of 3 possible forward locations, using greedy method described in assignment.
   * @return the total change in elevation traveled from West-to-East
   */
  public int drawLowestElevPath(Graphics g, int row){
    int currY = row; // row in grid of step one
    // draw initial step - column 0, current row (sent in as parameter)
    g.fillRect(0,row,1,1);
    
    // Code to compute next step

    int elevChange = 0;
    int changeL = 0;
    int changeS = 0;
    int changeR = 0;
    

    // draw next step where x is currently column and currY is row in grid
    int x = 0; 
    int nextStep = grid[currY][x];
    // the value of x will be generated by a loop that goes through the
    // columns, but for now, need something to put in "paint" statement
    for (x = 0; x < grid.length; x++) {
        for (int column = 1; column < grid[0].length -1; column++) {
        	int current = grid[currY][column-1];
        	
        	changeS = Math.abs(current - grid[currY][column]);
        	
        	if (currY > 0) {
        		changeL = Math.abs(current - grid[currY-1][column]);
        	}
        	else {
        		changeL = Integer.MAX_VALUE;
        	}
        	
        	if (currY < grid.length - 1) {
        		changeR = Math.abs(current - grid[currY+1][column]);
        	}
        	else {
        		changeR = Integer.MAX_VALUE;
        	}
        	
        	
        	if (changeS <= changeL && changeS <= changeR) {
        		
        		elevChange = elevChange + changeS;
        	}
//        	else if (changeS == changeL && changeS < changeR) {
//        		elevChange = elevChange + changeS;
//        	}
//        	else if (changeS == changeR && changeS < changeL) {
//        		elevChange = elevChange + changeS;
//        	}
//        	else if (changeS == changeR && changeS == changeL) {
//        		elevChange = elevChange + changeS;
//        	}
        	else if (changeL < changeS) {
        		currY = currY -1;
        		elevChange = elevChange + changeL;
        	}
        	else if (changeR < changeS) {
        		currY = currY + 1;
        		elevChange = elevChange + changeR;
        	}
        	else if (changeR == changeL) {
        		double random = Math.random();
     
        		if (random < .50) {
        			currY = currY + 1;
        		}
        		else {
        			currY = currY - 1;
        		}
        		elevChange = elevChange + changeR;
        	}

        	nextStep = grid[currY][x];	
            
        }
    			
    }
    
    
    return elevChange; // computed change in elevation
  }
  
  /**
   * @return the index of the starting row for the lowest-elevation-change path in the entire grid.
   */
  public int indexOfLowestElevPath(Graphics g){
      int minElevChange = drawLowestElevPath(g, 0);
      System.out.println(minElevChange);
	  int lowestIndex = grid[0][0];
      int pathElevChange = 0;
	  for (int i = 0; i <grid.length - 1; i++) {
		  pathElevChange = drawLowestElevPath(g, i);
		  if (pathElevChange < minElevChange) {
			  lowestIndex = i;
		  }
		  
		  
	  }
	  //System.out.println(lowestIndex + " lowest index" + minElevChange + " elevChange");
      return lowestIndex; // row of path with lowest elevation
  
  }
  
  
}