/**
 * CSCI 221, HW 2 (McCauley)
 * Base code provided by instructor and updated by:
 * 
 * Richard Marshall
 */

import java.util.*;
import java.io.*;
import java.awt.*;


public class MapDataDrawer
{
  // store map data in grid array
  private int[][] grid; 
  
  // Read 2D array into grid. Data in file "filename", grid is rows x cols
   public MapDataDrawer(String filename, int rows, int cols) throws Exception{
      // initialize grid 
      grid = new int[rows][cols];
      //read the data from the file into the grid
      Scanner S = new Scanner(new File(filename));    
      
       for(int row=0; row < grid.length; row++){
          for(int col=0; col<grid[0].length; col++){
             grid[row][col] = S.nextInt(); 
          }
       }
      
  }

  
  /**
   * @return the min value in the entire grid
   */
  public int findMin(){
      
      int minVal = grid[0][0];
      
      for (int row = 0; row < grid.length; row++){ 
          for (int col = 0; col < grid[0].length; col++ ){
              if (grid[row][col] < minVal) {
                  minVal = grid[row][col];
                }
            }
        }
      
      return minVal;  
  }
  
  /**
   * @return the max value in the entire grid
   */
  public int findMax(){
      
      int maxVal = grid[0][0];
      
      for (int row = 0; row < grid.length; row++){
          for (int col = 0; col < grid[0].length; col++ ){
              if (grid[row][col] > maxVal) {
                  maxVal = grid[row][col];
                }
            }
        }

      return maxVal; 
  }
  
  /**
   * @param col the column of the grid to check
   * @return the index of the row with the lowest value in the given col for the grid
   */
  public  int indexOfMinRow(int col){
      int minIndex = 0;
      int minVal = grid[0][col];
      
      for (int row = 0; row < grid.length; row++) {
          if (grid[row][col] < minVal){
              minVal = grid[row][col];
              minIndex = row;
            }
        }
      
      return minIndex;  
  }
  
  
  /**
   * DON'T CHANGE THIS CODE
   * Draws the grid using the given Graphics object. 
   * Colors should be grayscale values 0-255, scaled based on min/max values in grid
   * 
   * ALERT:Until your findMin and findMax methods work, your output will
   * be a completely black graph.
   */
  public void drawMap(Graphics g){
      
    int minVal = findMin();
    int maxVal = findMax();
    double range = maxVal - minVal;
    
    for(int row=0; row < grid.length; row++){
      for(int col=0; col<grid[0].length; col++){
         int val = (int)(((grid[row][col]-minVal)/range) * 255);
         //g.setColor(new Color(val,255-val,255-val));
         g.setColor(new Color(val,val,val));
         g.fillRect(col,row,1,1);
        }
    }      
  }
  

   /**
   * Find a path from West-to-East starting at given row.
   * Choose a foward step out of 3 possible forward locations, using greedy method described in assignment.
   * @return the total change in elevation traveled from West-to-East
   */
  public int drawLowestElevPath(Graphics g, int row){
    int currY = row; // row in grid of step one
    int totalChangeElev = 0;
    // draw initial step - column 0, current row (sent in as parameter)
    g.fillRect(0,row,1,1);
    
    // Code to compute next step
    
    // draw next step where x is currently column and currY is row in grid
    int x = 0; // the value of x will be generated by a loop that goes through the
    // columns, but for now, need something to put in "paint" statement
    
    for (x = 1; x < grid[0].length; x++) {
        int[] steps = {currY - 1, currY, currY + 1};
        
        if (steps[0] < 0) {
            steps[0] = currY;
        }
        
        if (steps[2] >= grid.length) {
            steps[2] = currY;
        }
        
        int minStep = Math.abs(grid[currY][x-1] - grid[currY][x]); // this is finding the change in elevation 
        // in the step directly in front of the current position. This is used as a benchmark in the comparison
        // find the lowest change in elevation among the steps.
        int nextY = currY; //nextY is the Y val for the next step which is calculated below
        
        for (int i = 0; i < steps.length; i++) {
            int currentElev = grid[currY][x-1];
            int newElev = grid[steps[i]][x];
            int changeElev = Math.abs(currentElev - newElev);
            
            if (changeElev < minStep) {
                minStep = changeElev;
                nextY = steps[i];
            }
            
            if (changeElev == minStep) { // this code will decide between ties in elevation randomly to allow varying paths like the example
                Random randomNum = new Random();
                int result = randomNum.nextInt(2); // this generates an int, either 0 or 1 randomly
                
                if (result == 0) { // we check the generated int here. If it's 0 we change the step to the new step, else we leave it as the old step
                    minStep = changeElev;
                    nextY = steps[i];
                }
            }
        }
        
        totalChangeElev += minStep; //updates the totalChangeElev with the data fro mthe new step
        currY = nextY; //updates the current row
        
        g.fillRect(x,currY,1,1); // draws the path
    }
    
    return totalChangeElev; // returns tallied change in elevation
  }
  
  /**
   * @return the index of the starting row for the lowest-elevation-change path in the entire grid.
   */
  public int indexOfLowestElevPath(Graphics g){
      int minRow = 0;
      int minElev = drawLowestElevPath(g,0);
      
      for (int row = 1; row < grid.length; row++) { //this loop goes through a path for each row and finds the 
          int rowElev = drawLowestElevPath(g,row); //row with the lowests over all change in elevation from the return
                                                    // of the drawLowestElevationPath method
          if (rowElev < minElev) {
              minRow = row;
              minElev = rowElev;
            }
      }
     
      return minRow; // row of path with lowest elevation
  
  }
  
  
}