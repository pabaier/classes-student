/**
 * CSCI 221, HW 2 (McCauley)
 * Base code provided by instructor and updated by:
 * methods to calculate lowest change in elevation using a greedy algorithm
 * Matt Hancock
 */

import java.util.*;
import java.io.*;
import java.awt.*;

public class MapDataDrawer
{
  // store map data in grid array
  private int[][] grid; 
  
  // Read 2D array into grid. Data in file "filename", grid is rows x cols
   public MapDataDrawer(String filename, int rows, int cols) throws Exception{
      // initialize grid 
      grid = new int[rows][cols];
      //read the data from the file into the grid
      Scanner S = new Scanner(new File(filename));    
      
       for(int row=0; row < grid.length; row++){
          for(int col=0; col<grid[0].length; col++){
             grid[row][col] = S.nextInt(); 
          }
       }
      
  }

  
  /**
   * @return the min value in the entire grid
   */
  public int findMin(){
      int MIN_VALUE = grid[0][0];
      for(int i = 0; i < grid.length; i++){
          for(int j=0; j<grid[0].length; j++){
             if(grid[i][j] < MIN_VALUE){
                 MIN_VALUE = grid[i][j];
          }
        }
  }
  return MIN_VALUE;  
}
  
  /**
   * @return the max value in the entire grid
   */
  public int findMax(){
      int MAX_VALUE = grid[0][0];
      for(int i = 0; i < grid.length; i++){
          for(int j=0; j<grid[0].length; j++){
             if(grid[i][j] > MAX_VALUE){
                 MAX_VALUE = grid[i][j];
          }
       }
  }
  return MAX_VALUE;
}
  
  /**
   * @param col the column of the grid to check
   * @return the index of the row with the lowest value in the given col for the grid
   */
  public  int indexOfMinRow(int col){
      int minInRow = 1000000; 
      int row = 0;
      int num = 0;
      for(row = 0; row < grid.length; ++row){
          if(grid[row][col]<minInRow){
              minInRow = grid[row][col];
              num = row;
            }
            }

      return num;  
  }
  
  
  /**
   * DON'T CHANGE THIS CODE
   * Draws the grid using the given Graphics object. 
   * Colors should be grayscale values 0-255, scaled based on min/max values in grid
   * 
   * ALERT:Until your findMin and findMax methods work, your output will
   * be a completely black graph.
   */
  public void drawMap(Graphics g){
      
    int minVal = findMin();
    int maxVal = findMax();
    double range = maxVal - minVal;
    
    for(int row=0; row < grid.length; row++){
      for(int col=0; col<grid[0].length; col++){
         int val = (int)(((grid[row][col]-minVal)/range) * 255);
         //g.setColor(new Color(val,255-val,255-val));
         g.setColor(new Color(val,val,val));
         g.fillRect(col,row,1,1);
        }
    }      
  }
  

   /**
   * Find a path from West-to-East starting at given row.
   * Choose a foward step out of 3 possible forward locations, using greedy method described in assignment.
   * @return the total change in elevation traveled from West-to-East
   */
  public int drawLowestElevPath(Graphics g, int minRow){
    int currY = minRow; // row in grid of step one
    // draw initial step - column 0, current row (sent in as parameter)
    g.fillRect(0,currY,1,1);
    int col = 0; // the value of x will be generated by a loop that goes through the
    // columns, but for now, need something to put in "paint" statement
    int elevChange = 0;
    // Code to compute next step
    for(col = 0 ; col < grid[0].length - 1 ; ++col){
        int stepUp = 0;
        int stepForward = 0;
        int stepDown = 0;
        int currVal = grid[currY][col];
        //exclude top boundary
        if(currY == 0){
            stepForward = grid[currY][col+1];
            stepDown = grid[currY+1][col+1];
            
            if(Math.abs(currVal-stepForward) <= Math.abs(currVal-stepDown)){
                currY = currY;
                elevChange += Math.abs(currVal-stepForward);
            }else{
                currY = currY + 1;
                elevChange += Math.abs(currVal-stepDown);
            }
        }
        //meat of the rows
        else if(currY>0 && currY < 479){
            stepUp = grid[currY-1][col+1];
            stepForward = grid[currY][col+1];
            stepDown = grid[currY+1][col+1];
            if(Math.abs(currVal-stepForward) <= Math.abs(currVal-stepDown) && (currVal-stepForward) <= Math.abs(currVal-stepUp)){
                currY = currY;
                elevChange += Math.abs(currVal-stepForward);
            }else if(Math.abs(currVal-stepDown) > Math.abs(currVal-stepUp)){
                currY = currY-1;
                elevChange += Math.abs(currVal-stepUp);
            }
            else if(Math.abs(currVal-stepDown) < Math.abs(currVal-stepUp)){
                currY = currY+1;
                elevChange += Math.abs(currVal-stepDown);
            }
            else{
                Random rand = new Random();
                int  n = rand.nextInt(2)+0;
                //random decision to go up or down. 
                if(n==0){
                    currY = currY+1;
                    elevChange += Math.abs(currVal-stepDown);
                }else{
                    currY = currY-1;
                    elevChange += Math.abs(currVal-stepUp);
                }  
            }
        }
        
        //exclude bottom boundary
        else if(currY == 479){
            
            stepUp = grid[currY-1][col+1];
            stepForward = grid[currY][col+1];
            if(Math.abs(currVal-stepForward) <= Math.abs(currVal-stepUp)){
                currY = currY;
                elevChange += Math.abs(currVal-stepForward);
            }else{
                currY = currY - 1;
                elevChange += Math.abs(currVal-stepUp);
            }
        }
        g.fillRect(col,currY,1,1);
    }
    // draw next step where x is currently column and currY is row in grid
    //int x = 0; // the value of x will be generated by a loop that goes through the
    // columns, but for now, need something to put in "paint" statement
    g.fillRect(col,currY,1,1);
    
    return elevChange; // computed change in elevation
  }
  
  /**
   * @return the index of the starting row for the lowest-elevation-change path in the entire grid.
   */
  public int indexOfLowestElevPath(Graphics g){
      int minChange = 1000000000;
      int minChangeRow = 0;
      for(int i = 1; i<480; ++i){
          drawLowestElevPath(g, i);
          if(drawLowestElevPath(g, i) < minChange){
              minChange = drawLowestElevPath(g, i);
              minChangeRow = i;
            }
            
        }
          
      
      return minChangeRow; // row of path with lowest elevation
  
  }
  
  
}