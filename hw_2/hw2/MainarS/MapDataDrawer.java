/**
 * CSCI 221, HW 2 (McCauley)
 * Base code provided by instructor and updated by:
 * 
 * Shaina Mae Mainar
 */

import java.util.*;
import java.io.*;
import java.awt.*;

public class MapDataDrawer
{
  // store map data in grid array
  private int[][] grid; 
  
  // Read 2D array into grid. Data in file "filename", grid is rows x cols
   public MapDataDrawer(String filename, int rows, int cols) throws Exception{
      // initialize grid 
      grid = new int[rows][cols];
      //read the data from the file into the grid
      Scanner S = new Scanner(new File(filename));    
      
       for(int row=0; row < grid.length; row++){
          for(int col=0; col<grid[0].length; col++){
             grid[row][col] = S.nextInt(); 
          }
       }
      
  }

  
  /**
   * @return the min value in the entire grid
   */ 
  public int findMin(){
      int min = grid[0][0];
      for(int i = 1; i < grid.length; ++i){
          for(int j = 1; j < grid[0].length; ++j){
              if(grid[i][j] < min){
                  min = grid[i][j];
                }
            }
        }
  
      return min;  
  }
  
  /**
   * @return the max value in the entire grid
   */
  public int findMax(){
      int max = grid[0][0];
      for(int i = 1; i < grid.length; ++i){
          for(int j = 1; j < grid[0].length; ++j){
              if(grid[i][j] > max){
                  max = grid[i][j];
                }
            }
        }
      return max; 
  }
  
  /**
   * @param col the column of the grid to check
   * @return the index of the row with the lowest value in the given col for the grid
   */
  public int indexOfMinRow(int col){
      int min = grid[0][col];
      int index = 0;
      for(int i = 1; i < grid.length; ++i){
          if(grid[i][col] < min){
              min = grid[i][col];
              index = i;
            }
        }
      return index;  
  }
  
  
  /**
   * DON'T CHANGE THIS CODE
   * Draws the grid using the given Graphics object. 
   * Colors should be grayscale values 0-255, scaled based on min/max values in grid
   * 
   * ALERT:Until your findMin and findMax methods work, your output will
   * be a completely black graph.
   */
  public void drawMap(Graphics g){
 
    int minVal = findMin();
    int maxVal = findMax();
    double range = maxVal - minVal;
    
    for(int row=0; row < grid.length; row++){
      for(int col=0; col<grid[0].length; col++){
         int val = (int)(((grid[row][col]-minVal)/range) * 255);
         //g.setColor(new Color(val,255-val,255-val));
         g.setColor(new Color(val,val,val));
         g.fillRect(col,row,1,1);
        }
    }      
  }
  

   /**
   * Find a path from West-to-East starting at given row.
   * Choose a foward step out of 3 possible forward locations, using greedy method described in assignment.
   * @return the total change in elevation traveled from West-to-East
   */
  public int drawLowestElevPath(Graphics g, int row){
    //int currY = row; // row in grid of step one
    int totChange = 0;
    int max = findMax();
    // draw initial step - column 0, current row (sent in as parameter)
    int x = 0; // the value of x will be generated by a loop that goes through the
    // columns, but for now, need something to put in "paint" statement
    for(x = 0; x < grid[0].length - 1; ++x){
        g.fillRect(x,row,1,1);
        int fwd = grid[row][x+1];
        int up = -1;
        int down = -1;
        
        //Catching edges so it doesn't throw out index out of bounds
        if(row != 0){
            up = grid[row - 1][x + 1];
        }
        if(row != grid.length - 1){
            down = grid[row + 1][x + 1];
        }
        
        int fwdDiff = Math.abs(grid[row][x] - fwd);
        int upDiff = max + 1;
        int downDiff = max + 1;
        
        if(up > -1){
            //upDiff
            upDiff = Math.abs(grid[row][x] - up);
        }
        if(down > -1){
            //downDiff
            downDiff = Math.abs(grid[row][x] - down);
        }
        
        int leastDiff = fwdDiff;
        
        if (fwdDiff > upDiff){
              
          if (upDiff > downDiff){
              leastDiff = downDiff;
              row++;
          }
          else if(upDiff == downDiff){
              Random rand = new Random();
              int j = rand.nextInt(2);
              if(j == 0){
                  leastDiff = upDiff;
                  row--;
              }
              else{
                  leastDiff = downDiff;
                  row++;
              }
                
          }
          else{
              leastDiff = upDiff;
              row--;
          }
        }
    
    
        else{
      
          if (fwdDiff > downDiff){
              leastDiff = downDiff;
              row++;
          }
          else{
              leastDiff = fwdDiff;
          } 
        }
          totChange += leastDiff;
    }
    // Code to compute next step
    // draw next step where x is currently column and row is row in grid
     

    
    return totChange; // computed change in elevation
  }
  
  /**
   * @return the index of the starting row for the lowest-elevation-change path in the entire grid.
   */
  public int indexOfLowestElevPath(Graphics g){
      int lowest = drawLowestElevPath(g, 0);
      int index = 0;
      for(int i = 1;  i < grid.length; ++i){
          if(grid[0][i] < lowest){
              lowest = grid[0][i];
              index = i;
            }
        }
        
      return index; // row of path with lowest elevation
  
  }
  
  
}